Got it. You want one Postgres query that, given a base location location_code (ex: 'AANAGA'), returns the full hierarchy under it (floors → rooms → cages → …) using:
location_uuid = unique id for each node
parent_loc_uuid = points to the parent’s location_uuid
element_type = tells whether it’s BaseLocation / Floor / Room / Cage / etc.
Below is a ready-to-paste prompt for Gemini/Copilot, and it already includes the exact recursive CTE query pattern.
Prompt to paste in Gemini / Copilot (with your screenshot)
Copy-paste this exactly (and attach the screenshot):
Copy code

You are a PostgreSQL expert.

I have a table named psc_site_code_info that stores a location hierarchy (Base Location -> Floor -> Room -> Cage -> etc).
Columns (names exactly):
- location_uuid (uuid): unique id for every node (base/floor/room/etc)
- parent_loc_uuid (uuid): parent pointer. For a child node, parent_loc_uuid = parent's location_uuid. Base location has parent_loc_uuid = NULL.
- location_code (text): location identifier (example base location code: 'AANAGA')
- element_type (text): type of node (examples: BaseLocation, Floor, Room, Cage, ...)

Goal:
Given a base location's location_code (example: 'AANAGA'), write a PostgreSQL query that returns the entire subtree under that base location:
- include the base location row and all descendants at any depth
- show level/depth (0 for base, 1 for its children, etc)
- show a readable path (like Base -> Floor -> Room -> ...)
- order results by path so hierarchy is readable

Use a recursive CTE (WITH RECURSIVE).

Also provide:
1) a second query that only returns descendants (excluding base)
2) index suggestions to make this fast (especially on parent_loc_uuid and location_code)

IMPORTANT: The base record must be identified using location_code='AANAGA' AND element_type='BaseLocation' (or element_type='BaseLocation' if needed).
Return columns: depth, location_uuid, parent_loc_uuid, location_code, element_type, path.
The actual Postgres query you want (so you can use immediately)
1) Full hierarchy including base (best default)
Copy code
Sql
WITH RECURSIVE loc_tree AS (
  -- Anchor: base location
  SELECT
      0 AS depth,
      t.location_uuid,
      t.parent_loc_uuid,
      t.location_code,
      t.element_type,
      (t.location_code || ' [' || t.element_type || ']')::text AS path
  FROM psc_site_code_info t
  WHERE t.location_code = 'AANAGA'
    AND t.element_type = 'BaseLocation'

  UNION ALL

  -- Children
  SELECT
      lt.depth + 1 AS depth,
      c.location_uuid,
      c.parent_loc_uuid,
      c.location_code,
      c.element_type,
      (lt.path || ' -> ' || c.location_code || ' [' || c.element_type || ']') AS path
  FROM psc_site_code_info c
  JOIN loc_tree lt
    ON c.parent_loc_uuid = lt.location_uuid
)
SELECT
    depth, location_uuid, parent_loc_uuid, location_code, element_type, path
FROM loc_tree
ORDER BY path;
2) Descendants only (exclude base)
Copy code
Sql
WITH RECURSIVE loc_tree AS (
  SELECT
      0 AS depth,
      t.location_uuid,
      t.parent_loc_uuid,
      t.location_code,
      t.element_type,
      (t.location_code || ' [' || t.element_type || ']')::text AS path
  FROM psc_site_code_info t
  WHERE t.location_code = 'AANAGA'
    AND t.element_type = 'BaseLocation'

  UNION ALL

  SELECT
      lt.depth + 1 AS depth,
      c.location_uuid,
      c.parent_loc_uuid,
      c.location_code,
      c.element_type,
      (lt.path || ' -> ' || c.location_code || ' [' || c.element_type || ']') AS path
  FROM psc_site_code_info c
  JOIN loc_tree lt
    ON c.parent_loc_uuid = lt.location_uuid
)
SELECT
    depth, location_uuid, parent_loc_uuid, location_code, element_type, path
FROM loc_tree
WHERE depth > 0
ORDER BY path;
3) Indexes (important for performance)
Copy code
Sql
CREATE INDEX IF NOT EXISTS idx_psc_site_code_info_parent
  ON psc_site_code_info(parent_loc_uuid);

CREATE INDEX IF NOT EXISTS idx_psc_site_code_info_location_code
  ON psc_site_code_info(location_code);

-- Optional if you always filter base by both:
CREATE INDEX IF NOT EXISTS idx_psc_site_code_info_code_type
  ON psc_site_code_info(location_code, element_type);
If your location_code for floors/rooms is something like AANAGA > FLOOR 1 etc, and only base has exact AANAGA, then the anchor filter I used is perfect. If instead multiple rows share the same location_code='AANAGA', tell me what distinguishes the base row (sometimes parent_loc_uuid IS NULL), and I’ll adjust the anchor condition.
